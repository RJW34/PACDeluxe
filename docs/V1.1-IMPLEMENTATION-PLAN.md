# PACDeluxe v1.1 Implementation Plan

## Executive Summary

v1.1 focuses on **observability, reliability, and user experience** - making the client smarter about what it's doing and giving users better control. No new performance primitives (WebView2 constraints remain), but significant improvements to visibility, caching intelligence, and overlay UX.

---

## Priority Matrix

| Priority | Feature | Impact | Effort | Risk |
|----------|---------|--------|--------|------|
| P0 | Smart Cache Versioning | High | Low | Low |
| P0 | Overlay Draggable/Dockable | High | Medium | Low |
| P1 | GPU Usage Monitoring | High | Medium | Medium |
| P1 | Network Metrics Enhancement | Medium | Low | Low |
| P1 | WebView2 Elevation Telemetry | Medium | Low | Low |
| P2 | Auto-Prewarm on First Load | Medium | Medium | Low |
| P2 | Borderless Windowed Mode | Medium | Medium | Low |
| P2 | Settings Persistence | Medium | Low | Low |
| P3 | Display Refresh Rate Detection | Low | Low | Low |
| P3 | Bandwidth Estimation | Low | Medium | Medium |

---

## P0: Critical (Ship Blockers)

### 1. Smart Cache Versioning

**Problem**: Asset cache persists across app updates. Stale assets can cause visual glitches or crashes when upstream changes asset formats.

**Solution**: Version-aware cache invalidation using upstream game build hash.

**Files to modify**:
- `src/performance/asset-cache.js`
- `scripts/build-frontend.js`

**Implementation**:

```javascript
// asset-cache.js additions
const CACHE_VERSION_KEY = '__pac_cache_version__';

async init(options = {}) {
  // Check if cache version matches current build
  const storedVersion = localStorage.getItem(CACHE_VERSION_KEY);
  const currentVersion = window.__PAC_BUILD_VERSION__ || 'unknown';

  if (storedVersion !== currentVersion) {
    console.log(`[AssetCache] Version mismatch (${storedVersion} -> ${currentVersion}), clearing cache`);
    this.clear();
    localStorage.setItem(CACHE_VERSION_KEY, currentVersion);
  }

  // ... existing init code
}
```

```javascript
// build-frontend.js additions
// After copying assets, inject build version
const buildVersion = crypto.createHash('sha256')
  .update(fs.readFileSync(indexJsPath))
  .digest('hex')
  .substring(0, 8);

// Inject into index.html
const versionScript = `<script>window.__PAC_BUILD_VERSION__="${buildVersion}";</script>`;
```

**Acceptance criteria**:
- Cache auto-clears when game version changes
- Cache persists across restarts when version unchanged
- Version displayed in overlay (debug mode)

---

### 2. Overlay Draggable/Dockable

**Problem**: Fixed top-right position overlaps game UI elements. Users can't reposition.

**Solution**: Make overlay draggable with snap-to-corner docking. Persist position.

**Files to modify**:
- `src/performance/profiling-overlay.js`

**Implementation**:

```javascript
// Add drag handling
initDragging() {
  const header = this.container.querySelector('.pac-overlay-header');
  let isDragging = false;
  let startX, startY, startLeft, startTop;

  header.style.cursor = 'move';

  header.addEventListener('mousedown', (e) => {
    if (e.target.classList.contains('pac-overlay-close')) return;
    isDragging = true;
    startX = e.clientX;
    startY = e.clientY;
    const rect = this.container.getBoundingClientRect();
    startLeft = rect.left;
    startTop = rect.top;
    e.preventDefault();
  });

  document.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    this.container.style.left = `${startLeft + dx}px`;
    this.container.style.top = `${startTop + dy}px`;
    this.container.style.right = 'auto';
  });

  document.addEventListener('mouseup', () => {
    if (isDragging) {
      isDragging = false;
      this.snapToCorner();
      this.savePosition();
    }
  });
}

snapToCorner() {
  const rect = this.container.getBoundingClientRect();
  const midX = window.innerWidth / 2;
  const midY = window.innerHeight / 2;

  // Snap to nearest corner
  const corners = {
    'top-left': { top: '10px', left: '10px', right: 'auto', bottom: 'auto' },
    'top-right': { top: '10px', right: '10px', left: 'auto', bottom: 'auto' },
    'bottom-left': { bottom: '10px', left: '10px', right: 'auto', top: 'auto' },
    'bottom-right': { bottom: '10px', right: '10px', left: 'auto', top: 'auto' },
  };

  const corner = (rect.left < midX ? 'left' : 'right');
  const edge = (rect.top < midY ? 'top' : 'bottom');
  const key = `${edge}-${corner}`;

  Object.assign(this.container.style, corners[key]);
  this.currentDock = key;
}

savePosition() {
  localStorage.setItem('pac_overlay_dock', this.currentDock);
}

loadPosition() {
  const saved = localStorage.getItem('pac_overlay_dock');
  if (saved) {
    this.currentDock = saved;
    // Apply saved position in applyStyles()
  }
}
```

**Acceptance criteria**:
- Overlay draggable by header
- Snaps to nearest corner on release
- Position persists across sessions
- Close button still works during drag

---

## P1: High Priority

### 3. GPU Usage Monitoring

**Problem**: Users see GPU name but no usage metrics. Can't tell if GPU-bound.

**Solution**: Query Windows Performance Counters for GPU usage via PDH API.

**Files to modify**:
- `src-tauri/src/performance.rs`
- `src-tauri/src/commands.rs`
- `src/performance/profiling-overlay.js`

**Implementation** (Rust):

```rust
// performance.rs additions
use windows::Win32::System::Performance::{
    PdhOpenQueryW, PdhAddEnglishCounterW, PdhCollectQueryData,
    PdhGetFormattedCounterValue, PDH_FMT_DOUBLE, PDH_HQUERY, PDH_HCOUNTER,
};

pub struct GpuMonitor {
    query: PDH_HQUERY,
    usage_counter: PDH_HCOUNTER,
}

impl GpuMonitor {
    pub fn new() -> Option<Self> {
        unsafe {
            let mut query = PDH_HQUERY::default();
            if PdhOpenQueryW(None, 0, &mut query).is_err() {
                return None;
            }

            // GPU Engine counter (Windows 10 1709+)
            // Counter path: \GPU Engine(*)\Utilization Percentage
            let counter_path = w!("\\GPU Engine(*)\\Utilization Percentage");
            let mut counter = PDH_HCOUNTER::default();

            if PdhAddEnglishCounterW(query, counter_path, 0, &mut counter).is_err() {
                return None;
            }

            Some(Self { query, usage_counter: counter })
        }
    }

    pub fn get_usage(&self) -> f32 {
        unsafe {
            if PdhCollectQueryData(self.query).is_err() {
                return 0.0;
            }

            let mut value = PDH_FMT_COUNTERVALUE::default();
            if PdhGetFormattedCounterValue(
                self.usage_counter,
                PDH_FMT_DOUBLE,
                None,
                &mut value
            ).is_ok() {
                value.Anonymous.doubleValue as f32
            } else {
                0.0
            }
        }
    }
}
```

```rust
// commands.rs additions
#[derive(Debug, Clone, Serialize)]
pub struct ExtendedStats {
    pub cpu_usage: f32,
    pub memory_usage_mb: u64,
    pub gpu_usage: f32,  // NEW
    pub uptime_secs: f64,
}

#[tauri::command]
pub async fn get_extended_stats(
    monitor: State<'_, PerformanceMonitor>,
    gpu_monitor: State<'_, Option<GpuMonitor>>,
) -> Result<ExtendedStats, String> {
    let stats = monitor.get_stats();
    let gpu_usage = gpu_monitor.as_ref()
        .map(|g| g.get_usage())
        .unwrap_or(0.0);

    Ok(ExtendedStats {
        cpu_usage: stats.cpu_usage,
        memory_usage_mb: stats.memory_usage_mb,
        gpu_usage,
        uptime_secs: stats.uptime_secs,
    })
}
```

**Note**: Windows Performance Counters are the only vendor-agnostic way to get GPU usage. Works on NVIDIA, AMD, and Intel without vendor SDKs.

**Acceptance criteria**:
- GPU usage displayed in overlay (0-100%)
- Graceful fallback if counters unavailable
- No vendor SDK dependencies

---

### 4. Network Metrics Enhancement

**Problem**: RTT only updates during navigation events. Bandwidth unknown.

**Solution**:
- Measure RTT on every Colyseus message (passive observation)
- Estimate bandwidth from recent transfer sizes/times

**Files to modify**:
- `src/performance/profiling-overlay.js`
- `src/performance/network-monitor.js` (NEW)

**Implementation**:

```javascript
// network-monitor.js (new file)
export class NetworkMonitor {
  constructor() {
    this.rttSamples = [];
    this.bandwidthSamples = [];
    this.maxSamples = 50;

    this.installObserver();
  }

  installObserver() {
    // PerformanceObserver for real-time resource timing
    if (typeof PerformanceObserver !== 'undefined') {
      const observer = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          this.processEntry(entry);
        }
      });

      observer.observe({ entryTypes: ['resource'] });
    }
  }

  processEntry(entry) {
    // Only process game server traffic
    if (!this.isGameTraffic(entry.name)) return;

    // RTT from connection time or response time
    const rtt = entry.responseEnd - entry.requestStart;
    if (rtt > 0 && rtt < 5000) {
      this.addRttSample(rtt);
    }

    // Bandwidth from transfer size / duration
    const transferSize = entry.transferSize || entry.encodedBodySize || 0;
    const duration = entry.responseEnd - entry.responseStart;
    if (transferSize > 0 && duration > 0) {
      const bps = (transferSize * 8) / (duration / 1000); // bits per second
      this.addBandwidthSample(bps);
    }
  }

  isGameTraffic(url) {
    return url.includes('colyseus') ||
           url.includes('pokemon-auto-chess') ||
           url.includes('socket');
  }

  addRttSample(rtt) {
    this.rttSamples.push({ value: rtt, time: Date.now() });
    if (this.rttSamples.length > this.maxSamples) {
      this.rttSamples.shift();
    }
  }

  addBandwidthSample(bps) {
    this.bandwidthSamples.push({ value: bps, time: Date.now() });
    if (this.bandwidthSamples.length > this.maxSamples) {
      this.bandwidthSamples.shift();
    }
  }

  getMetrics() {
    const recentRtts = this.rttSamples.slice(-20).map(s => s.value);
    const recentBw = this.bandwidthSamples.slice(-10).map(s => s.value);

    return {
      rtt: recentRtts.length > 0
        ? Math.round(recentRtts.reduce((a,b) => a+b, 0) / recentRtts.length)
        : 0,
      rttJitter: this.calculateStdDev(recentRtts),
      bandwidth: recentBw.length > 0
        ? recentBw.reduce((a,b) => a+b, 0) / recentBw.length
        : 0,
      sampleCount: this.rttSamples.length,
    };
  }

  calculateStdDev(values) {
    if (values.length < 2) return 0;
    const mean = values.reduce((a,b) => a+b, 0) / values.length;
    const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;
    return Math.round(Math.sqrt(variance));
  }

  formatBandwidth(bps) {
    if (bps >= 1000000) return `${(bps / 1000000).toFixed(1)} Mbps`;
    if (bps >= 1000) return `${(bps / 1000).toFixed(0)} Kbps`;
    return `${Math.round(bps)} bps`;
  }
}

export const networkMonitor = new NetworkMonitor();
```

**Acceptance criteria**:
- RTT updates with every network event (not just navigation)
- Bandwidth estimate displayed
- Jitter calculation more accurate (more samples)

---

### 5. WebView2 Elevation Telemetry

**Problem**: No visibility into whether WMI-based process elevation is working.

**Solution**: Expose telemetry via IPC command.

**Files to modify**:
- `src-tauri/src/performance.rs`
- `src-tauri/src/commands.rs`
- `src/performance/profiling-overlay.js`

**Implementation**:

```rust
// performance.rs additions
use std::sync::atomic::AtomicU32;

static PROCESSES_ELEVATED: AtomicU32 = AtomicU32::new(0);
static ELEVATION_MODE: AtomicBool = AtomicBool::new(false); // true = WMI, false = polling

pub fn get_elevation_telemetry() -> (u32, bool) {
    (
        PROCESSES_ELEVATED.load(Ordering::Relaxed),
        WMI_WATCHER_ACTIVE.load(Ordering::Relaxed),
    )
}

// In elevate_single_process(), after success:
PROCESSES_ELEVATED.fetch_add(1, Ordering::Relaxed);
```

```rust
// commands.rs
#[derive(Debug, Clone, Serialize)]
pub struct ElevationTelemetry {
    pub processes_elevated: u32,
    pub mode: String, // "wmi" or "polling"
    pub is_active: bool,
}

#[tauri::command]
pub fn get_elevation_telemetry() -> ElevationTelemetry {
    let (count, wmi_active) = crate::performance::get_elevation_telemetry();
    ElevationTelemetry {
        processes_elevated: count,
        mode: if wmi_active { "wmi" } else { "polling" }.to_string(),
        is_active: crate::performance::WEBVIEW_OPTIMIZER_RUNNING.load(Ordering::Relaxed),
    }
}
```

**Acceptance criteria**:
- Overlay shows "WMI" or "Poll" indicator
- Count of elevated processes visible in detailed mode
- Logs warning if polling fallback active

---

## P2: Medium Priority

### 6. Auto-Prewarm on First Load

**Problem**: `CRITICAL_ASSETS` is hardcoded. User must manually call `startPrewarm()`.

**Solution**: Auto-discover and cache assets during initial load, then prewarm intelligently on subsequent launches.

**Files to modify**:
- `src/performance/asset-cache.js`
- `src/index.js`

**Implementation**:

```javascript
// asset-cache.js additions
const DISCOVERED_ASSETS_KEY = '__pac_discovered_assets__';

async autoPrewarm() {
  // Load previously discovered assets
  const stored = localStorage.getItem(DISCOVERED_ASSETS_KEY);
  if (stored) {
    const assets = JSON.parse(stored);
    console.log(`[AssetCache] Auto-prewarming ${assets.length} discovered assets`);
    await this.prewarm(assets, { concurrency: 2 });
  }
}

recordDiscoveredAssets() {
  // Called after game fully loads
  const discovered = discoverPageAssets();
  const cached = Array.from(this.cache.keys());
  const allAssets = [...new Set([...discovered, ...cached])];

  localStorage.setItem(DISCOVERED_ASSETS_KEY, JSON.stringify(allAssets));
  console.log(`[AssetCache] Recorded ${allAssets.length} assets for future prewarm`);
}
```

```javascript
// index.js modifications
// After game loads (detect via MutationObserver or game state)
window.addEventListener('load', () => {
  // Wait for game to stabilize
  setTimeout(() => {
    assetCache.recordDiscoveredAssets();
  }, 30000); // 30 seconds after load
});

// On startup
assetCache.init().then(() => {
  assetCache.autoPrewarm();
});
```

**Acceptance criteria**:
- First launch: discovers and records assets
- Subsequent launches: prewarms from recorded list
- Prewarm non-blocking (uses requestIdleCallback)

---

### 7. Borderless Windowed Mode

**Problem**: Only standard windowed or fullscreen. No borderless option.

**Solution**: Implement borderless windowed via Tauri window API.

**Files to modify**:
- `src-tauri/src/commands.rs`
- `src-tauri/src/main.rs`
- `src/bridge/tauri-bridge.js`

**Implementation**:

```rust
// commands.rs
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]
pub enum WindowMode {
    Windowed,
    Fullscreen,
    BorderlessWindowed,
}

#[tauri::command]
pub async fn set_window_mode(app: AppHandle, mode: WindowMode) -> Result<(), String> {
    let window = app.get_webview_window("main")
        .ok_or("Main window not found")?;

    match mode {
        WindowMode::Windowed => {
            window.set_fullscreen(false).map_err(|e| e.to_string())?;
            window.set_decorations(true).map_err(|e| e.to_string())?;
        }
        WindowMode::Fullscreen => {
            window.set_fullscreen(true).map_err(|e| e.to_string())?;
        }
        WindowMode::BorderlessWindowed => {
            window.set_fullscreen(false).map_err(|e| e.to_string())?;
            window.set_decorations(false).map_err(|e| e.to_string())?;

            // Maximize to fill screen
            window.maximize().map_err(|e| e.to_string())?;
        }
    }

    Ok(())
}

#[tauri::command]
pub async fn get_window_mode(app: AppHandle) -> Result<WindowMode, String> {
    let window = app.get_webview_window("main")
        .ok_or("Main window not found")?;

    let is_fullscreen = window.is_fullscreen().unwrap_or(false);
    let is_decorated = window.is_decorated().unwrap_or(true);

    Ok(match (is_fullscreen, is_decorated) {
        (true, _) => WindowMode::Fullscreen,
        (false, false) => WindowMode::BorderlessWindowed,
        (false, true) => WindowMode::Windowed,
    })
}
```

**Acceptance criteria**:
- Three window modes available
- Keyboard shortcuts: F11 (fullscreen), Shift+F11 (borderless)
- Mode persists across sessions

---

### 8. Settings Persistence

**Problem**: Overlay visibility, position, and preferences don't persist.

**Solution**: Unified settings storage with localStorage.

**Files to modify**:
- `src/performance/settings.js` (NEW)
- `src/performance/profiling-overlay.js`

**Implementation**:

```javascript
// settings.js (new file)
const SETTINGS_KEY = '__pac_settings__';

const defaultSettings = {
  overlay: {
    visible: false,
    dock: 'top-right',
    mode: 'standard', // minimal, standard, detailed
    graphMode: 'line',
  },
  cache: {
    enabled: true,
    maxSizeMB: 256,
  },
  window: {
    mode: 'windowed',
  },
};

class Settings {
  constructor() {
    this.data = this.load();
  }

  load() {
    try {
      const stored = localStorage.getItem(SETTINGS_KEY);
      return stored ? { ...defaultSettings, ...JSON.parse(stored) } : defaultSettings;
    } catch {
      return defaultSettings;
    }
  }

  save() {
    localStorage.setItem(SETTINGS_KEY, JSON.stringify(this.data));
  }

  get(path) {
    return path.split('.').reduce((obj, key) => obj?.[key], this.data);
  }

  set(path, value) {
    const keys = path.split('.');
    const last = keys.pop();
    const target = keys.reduce((obj, key) => obj[key] ??= {}, this.data);
    target[last] = value;
    this.save();
  }
}

export const settings = new Settings();
```

**Acceptance criteria**:
- All user preferences persist across sessions
- Settings survive app updates (stored in localStorage)
- Defaults applied for new users

---

## P3: Nice-to-Have

### 9. Display Refresh Rate Detection

**Problem**: Assumes 60Hz. Can't tell if VRR/144Hz active.

**Solution**: Use `window.screen` API and measure actual frame delivery.

**Files to modify**:
- `src/performance/frame-monitor.js`

**Implementation**:

```javascript
// frame-monitor.js additions
detectRefreshRate() {
  // Method 1: Screen API (if available)
  if (window.screen?.refreshRate) {
    return window.screen.refreshRate;
  }

  // Method 2: Infer from actual frame delivery
  // After 120 frames, calculate actual rate
  if (this.frameTimes.length >= 60) {
    const avgFrameTime = this.frameTimes.reduce((a,b) => a+b, 0) / this.frameTimes.length;
    const inferredFps = 1000 / avgFrameTime;

    // Round to common refresh rates
    const commonRates = [60, 75, 90, 120, 144, 165, 240];
    return commonRates.reduce((prev, curr) =>
      Math.abs(curr - inferredFps) < Math.abs(prev - inferredFps) ? curr : prev
    );
  }

  return 60; // Default
}
```

**Acceptance criteria**:
- Detected refresh rate shown in overlay
- Frame monitor adjusts dropped frame threshold accordingly

---

### 10. Bandwidth Estimation

**Problem**: No visibility into network bandwidth.

**Solution**: Covered in P1 #4 (Network Metrics Enhancement).

---

## Implementation Order

### Phase 1 (Week 1)
1. Smart Cache Versioning (P0) - 2-3 hours
2. WebView2 Elevation Telemetry (P1) - 1-2 hours
3. Network Metrics Enhancement (P1) - 3-4 hours

### Phase 2 (Week 2)
4. Overlay Draggable/Dockable (P0) - 4-5 hours
5. Settings Persistence (P2) - 2-3 hours
6. Auto-Prewarm on First Load (P2) - 3-4 hours

### Phase 3 (Week 3)
7. GPU Usage Monitoring (P1) - 6-8 hours (most complex)
8. Borderless Windowed Mode (P2) - 2-3 hours
9. Display Refresh Rate Detection (P3) - 1-2 hours

---

## Testing Strategy

### Manual Testing
- [ ] Fresh install: cache version set, no stale assets
- [ ] Upgrade install: cache cleared, new version cached
- [ ] Overlay: drag to each corner, verify snap
- [ ] Overlay: position persists across restart
- [ ] GPU: usage shows in overlay, matches Task Manager
- [ ] Network: RTT updates during gameplay
- [ ] Borderless: mode toggles correctly

### Automated Testing
- Add to `tests/ethical-safeguards.test.js`:
  - Settings storage doesn't contain game state
  - Cache versioning doesn't read game data
  - Network monitor is passive (no injected traffic)

---

## Risk Mitigation

| Risk | Mitigation |
|------|------------|
| GPU counters unavailable | Graceful fallback, hide GPU metric |
| WMI fails on some systems | Already have polling fallback |
| localStorage quota exceeded | Rotate old data, cap settings size |
| Drag performance on slow systems | Throttle mousemove handler |

---

## Non-Goals for v1.1

- GPU vendor SDKs (NVIDIA NVML, AMD ADL)
- Frame pacing control (WebView2 limitation)
- Exclusive fullscreen (WebView2 limitation)
- Multi-monitor awareness (future)
- Gamepad input latency (no gamepad support in game)
- Cloud settings sync

---

## Success Metrics

| Metric | Target |
|--------|--------|
| Cache hit rate | >80% after prewarm |
| Overlay update latency | <50ms |
| GPU counter availability | >90% of Windows 10 1709+ |
| Settings load time | <10ms |

---

## Appendix: Files Changed

```
src/
├── performance/
│   ├── asset-cache.js        # P0: versioning, P2: auto-prewarm
│   ├── profiling-overlay.js  # P0: draggable, P1: GPU/network display
│   ├── network-monitor.js    # P1: NEW file
│   ├── frame-monitor.js      # P3: refresh detection
│   └── settings.js           # P2: NEW file
├── bridge/
│   └── tauri-bridge.js       # P1: new commands
└── index.js                  # P2: auto-prewarm init

src-tauri/src/
├── performance.rs            # P1: GPU monitor, elevation telemetry
├── commands.rs               # P1: new IPC commands, P2: window modes
└── main.rs                   # Register new commands

scripts/
└── build-frontend.js         # P0: inject build version
```
