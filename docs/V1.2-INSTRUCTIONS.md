# V1.2 Implementation Instructions

**Trigger:** When user says "begin", implement all features below in order.

---

## Pre-Implementation Checklist

1. Run `git stash list` to check for stashed borderless windowed changes
2. Current stable version: v1.1.10
3. All features are LOW RISK unless noted

---

## Feature 1: Smart Cache Versioning (P0)

**Goal:** Auto-clear IndexedDB cache when upstream game version changes.

**Files to modify:**
- `scripts/build-frontend.js` - Inject build version hash
- `src/performance/asset-cache.js` - Check version on init

**Implementation:**

### Step 1: build-frontend.js
Add after line where index.js is copied:
```javascript
// Generate build version from game files hash
const crypto = require('crypto');
const indexContent = fs.readFileSync(path.join(distDir, 'index.js'), 'utf8');
const buildVersion = crypto.createHash('sha256')
  .update(indexContent)
  .digest('hex')
  .substring(0, 8);

// Inject version into index.html
const indexHtmlPath = path.join(distDir, 'index.html');
let indexHtml = fs.readFileSync(indexHtmlPath, 'utf8');
const versionScript = `<script>window.__PAC_BUILD_VERSION__="${buildVersion}";</script>`;
indexHtml = indexHtml.replace('</head>', `${versionScript}</head>`);
fs.writeFileSync(indexHtmlPath, indexHtml);
console.log(`[build] Injected build version: ${buildVersion}`);
```

### Step 2: asset-cache.js
Add at top of init() method:
```javascript
const CACHE_VERSION_KEY = '__pac_cache_version__';
const storedVersion = localStorage.getItem(CACHE_VERSION_KEY);
const currentVersion = window.__PAC_BUILD_VERSION__ || 'unknown';

if (storedVersion && storedVersion !== currentVersion) {
  console.log(`[AssetCache] Version mismatch (${storedVersion} -> ${currentVersion}), clearing cache`);
  await this.clear();
}
localStorage.setItem(CACHE_VERSION_KEY, currentVersion);
```

---

## Feature 2: Overlay Draggable/Dockable (P0)

**Goal:** Let users drag the performance overlay and snap to corners.

**Files to modify:**
- `src-tauri/src/main.rs` - OVERLAY_SCRIPT section

**Implementation:**

Add to OVERLAY_SCRIPT after overlay creation:
```javascript
// Make overlay draggable
let isDragging = false;
let dragStartX, dragStartY, overlayStartX, overlayStartY;

overlay.style.cursor = 'move';

overlay.addEventListener('mousedown', (e) => {
    isDragging = true;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    const rect = overlay.getBoundingClientRect();
    overlayStartX = rect.left;
    overlayStartY = rect.top;
    overlay.style.right = 'auto';
    overlay.style.left = rect.left + 'px';
    e.preventDefault();
});

document.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    const dx = e.clientX - dragStartX;
    const dy = e.clientY - dragStartY;
    overlay.style.left = (overlayStartX + dx) + 'px';
    overlay.style.top = (overlayStartY + dy) + 'px';
});

document.addEventListener('mouseup', () => {
    if (!isDragging) return;
    isDragging = false;

    // Snap to nearest corner
    const rect = overlay.getBoundingClientRect();
    const midX = window.innerWidth / 2;
    const midY = window.innerHeight / 2;

    const isLeft = rect.left + rect.width/2 < midX;
    const isTop = rect.top + rect.height/2 < midY;

    overlay.style.left = isLeft ? '8px' : 'auto';
    overlay.style.right = isLeft ? 'auto' : '8px';
    overlay.style.top = isTop ? '8px' : 'auto';
    overlay.style.bottom = isTop ? 'auto' : '8px';

    // Persist position
    const dock = (isTop ? 'top' : 'bottom') + '-' + (isLeft ? 'left' : 'right');
    localStorage.setItem('pac_overlay_dock', dock);
});

// Restore saved position on load
const savedDock = localStorage.getItem('pac_overlay_dock');
if (savedDock) {
    const [vertical, horizontal] = savedDock.split('-');
    overlay.style.top = vertical === 'top' ? '8px' : 'auto';
    overlay.style.bottom = vertical === 'bottom' ? '8px' : 'auto';
    overlay.style.left = horizontal === 'left' ? '8px' : 'auto';
    overlay.style.right = horizontal === 'right' ? '8px' : 'auto';
}
```

---

## Feature 3: Settings Persistence (P2)

**Goal:** Remember overlay visibility across sessions.

**Files to modify:**
- `src-tauri/src/main.rs` - OVERLAY_SCRIPT section

**Implementation:**

Modify overlay visibility logic:
```javascript
// Replace: let visible = false;
// With:
let visible = localStorage.getItem('pac_overlay_visible') === 'true';
overlay.style.display = visible ? 'block' : 'none';
if (visible) updateOverlay();

// In the Ctrl+Shift+P handler, add after toggling:
localStorage.setItem('pac_overlay_visible', visible);
```

---

## Feature 4: Refresh Rate Detection (P3)

**Goal:** Detect and display monitor refresh rate in overlay.

**Files to modify:**
- `src-tauri/src/main.rs` - OVERLAY_SCRIPT section

**Implementation:**

Add refresh rate detection:
```javascript
// Detect refresh rate by measuring frame delivery
let refreshRate = 60; // Default
const frameTimes = [];
let lastFrameTime = performance.now();

function measureRefreshRate() {
    const now = performance.now();
    const delta = now - lastFrameTime;
    lastFrameTime = now;

    if (delta > 0 && delta < 100) { // Sanity check
        frameTimes.push(delta);
        if (frameTimes.length > 60) frameTimes.shift();

        if (frameTimes.length >= 30) {
            const avgDelta = frameTimes.reduce((a,b) => a+b, 0) / frameTimes.length;
            const measuredRate = Math.round(1000 / avgDelta);

            // Round to common refresh rates
            const common = [60, 75, 90, 120, 144, 165, 240];
            refreshRate = common.reduce((prev, curr) =>
                Math.abs(curr - measuredRate) < Math.abs(prev - measuredRate) ? curr : prev
            );
        }
    }
    requestAnimationFrame(measureRefreshRate);
}
requestAnimationFrame(measureRefreshRate);
```

Add to overlay HTML:
```javascript
<div>HZ: <span class="hz-val">--</span></div>
```

Add to updateOverlay():
```javascript
const hzEl = overlay.querySelector('.hz-val');
// In update function:
hzEl.textContent = refreshRate;
```

---

## Feature 5: Network Metrics Enhancement (P1)

**Goal:** Show real-time RTT from game traffic.

**Files to modify:**
- `src-tauri/src/main.rs` - OVERLAY_SCRIPT section

**Implementation:**

Add PerformanceObserver for network timing:
```javascript
// Network metrics
let networkRtt = 0;
const rttSamples = [];

if (typeof PerformanceObserver !== 'undefined') {
    const netObserver = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
            // Filter for game traffic
            if (entry.name.includes('colyseus') ||
                entry.name.includes('pokemon-auto-chess') ||
                entry.name.includes('socket')) {

                const rtt = entry.responseEnd - entry.requestStart;
                if (rtt > 0 && rtt < 5000) {
                    rttSamples.push(rtt);
                    if (rttSamples.length > 20) rttSamples.shift();
                    networkRtt = Math.round(
                        rttSamples.reduce((a,b) => a+b, 0) / rttSamples.length
                    );
                }
            }
        }
    });

    try {
        netObserver.observe({ entryTypes: ['resource'] });
    } catch(e) {
        console.log('[PACDeluxe] Network observer not available');
    }
}
```

Add to overlay HTML:
```javascript
<div>RTT: <span class="rtt-val">--</span> ms</div>
```

Add to updateOverlay():
```javascript
const rttEl = overlay.querySelector('.rtt-val');
// In update function:
rttEl.textContent = networkRtt || '--';
```

---

## Feature 6: Auto-Prewarm Assets (P2)

**Goal:** Learn which assets are used and prewarm them on next launch.

**Files to modify:**
- `src/performance/asset-cache.js`

**Implementation:**

Add to asset-cache.js:
```javascript
const DISCOVERED_ASSETS_KEY = '__pac_discovered_assets__';

// Call after game loads (30 seconds after page load)
recordDiscoveredAssets() {
    const cached = Array.from(this.cache.keys());
    localStorage.setItem(DISCOVERED_ASSETS_KEY, JSON.stringify(cached));
    console.log(`[AssetCache] Recorded ${cached.length} assets for prewarm`);
}

// Call on init
async autoPrewarm() {
    const stored = localStorage.getItem(DISCOVERED_ASSETS_KEY);
    if (stored) {
        try {
            const assets = JSON.parse(stored);
            console.log(`[AssetCache] Auto-prewarming ${assets.length} assets`);
            // Prewarm in background with low priority
            for (const url of assets.slice(0, 50)) { // Limit to 50
                if (!this.cache.has(url)) {
                    fetch(url).catch(() => {}); // Fire and forget
                    await new Promise(r => setTimeout(r, 100)); // Rate limit
                }
            }
        } catch(e) {}
    }
}
```

---

## Feature 7: GPU Usage Monitoring (P1) - MEDIUM RISK

**Goal:** Show GPU usage % using Windows Performance Counters.

**Files to modify:**
- `src-tauri/src/performance.rs`
- `src-tauri/Cargo.toml` (may need pdh feature)

**Note:** This uses PDH API which requires Windows Performance Counters to be available. May not work on all systems.

**Implementation:** See V1.2-IMPLEMENTATION-PLAN.md for full Rust code.

**Skip if:** Time constrained or want to avoid Windows API complexity.

---

## Feature 8: Borderless Windowed Mode (P2) - STASHED

**Status:** Already implemented and stashed.

**To restore:**
```bash
git stash pop
```

**Files affected:**
- `src-tauri/src/commands.rs` - WindowMode enum, set_window_mode, get_window_mode
- `src-tauri/src/main.rs` - Shift+F11 keyboard shortcut

---

## Implementation Order (Recommended)

1. **Settings Persistence** (5 min) - Quick win, no risk
2. **Refresh Rate Detection** (10 min) - Display only
3. **Overlay Draggable** (15 min) - User experience
4. **Smart Cache Versioning** (15 min) - Prevents bugs
5. **Network Metrics** (10 min) - Informational
6. **Auto-Prewarm** (15 min) - Performance
7. **Borderless Windowed** (stashed) - Restore when ready
8. **GPU Usage** (30 min) - Skip if time constrained

---

## Post-Implementation

1. Test each feature locally with `npm run tauri:dev`
2. Bump version to v1.2.0
3. Commit with descriptive message
4. Push and tag for release
5. Set timer to verify build

---

## Rollback Plan

If any feature causes issues:
```bash
git revert HEAD  # Revert last commit
git push origin master
git tag -d v1.2.0  # Delete local tag
git push origin :refs/tags/v1.2.0  # Delete remote tag
```

Then re-release as v1.2.1 with fix or feature removed.
